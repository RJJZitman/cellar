{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cellar DB &amp; API application","text":"<p>Monitor your wine/beer cellar contents.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>General project information</li> <li>Reference to important docs</li> <li>Preliminaries concerning DB setup</li> <li>Setting up after cloning the repo</li> </ul>"},{"location":"#general-project-information","title":"General project information","text":"<p>This project lends it existence to the desire of an administrative support tool for my private wine fridge. I'm using  it to store and age both wines and beers, but haven't been able to properly keep track of what's in there. More  importantly, I've recently come across a few bottles that should have been downed when they were still at their peak.  Instead, they were downed past their peak. Which is, rather obviously, an ill investment regarding the pleasure derived  from this hobby.</p> <p>This application is built to prevent exactly that and assist in keeping track of what bottles you have stored in your  private climate controlled storage unit. The way it is designed allows for multiple users of the application (i.e.,  wine/beer owners) simultaneously leveraging the app's benefits from wherever they are. Yet, further development for  that to happen is required. At this moment, the API service can only be run and accessed from your localhost. Updates  hereon will follow soon!</p> <p>Cheers,\\ Rogier</p>"},{"location":"#reference-to-important-docs","title":"Reference to important docs","text":"<p>There's a bunch of packages that this project relies on, which deserve an honourable mention. The foremost two are  FastAPI for the API service and MariaDB as the supporting DBMS.</p> <p>On another thread, notable mentions are pytest, which is used as the testing framework, SQLlite used as a substitute to  MariaDB within the testing scope and (quite naturally) pydantic for validating the data that flows through the API.  Finally, JWT is used for the encoding and decoding of API access tokens.</p> <p>Docs refs: * FastAPI   * https://fastapi.tiangolo.com   * https://fastapi.tiangolo.com/tutorial/testing/ * MariaDB   * https://mariadb.com   * https://dlm.mariadb.com/2531428/Connectors/java/connector-java-3.0.8/mariadb-java-client-3.0.8.jar * Notables   * https://docs.pytest.org/en/7.1.x/contents.html   * https://www.sqlite.org/index.html   * https://docs.pydantic.dev/latest/concepts/models/   * https://pyjwt.readthedocs.io/en/stable/index.html</p>"},{"location":"#preliminaries-concerning-db-setup","title":"Preliminaries concerning DB setup","text":"<p>Create your preferred kind of virtual environment to run all your scripts in and make sure to link it to the repo in  your IDE. Also, use the second link provided at the MariaDB refs to download the driver jar used by the python scripts  to connect to the MariaDB DB service. The MariaDB service itself should be installed with brew by  \"brew install mariadb\". The DB service can arbitrarily be started or stopped by using the \"brew services start mariadb\"  and \"brew services start mariadb\" commands respectively.</p> <p>Start the DB service and create a DB user that is specifically meant to be used by the API. Save the credentials for  later and make sure that this user has all possible privileges as long as you're only running the service locally.</p>"},{"location":"#setting-up-after-cloning-the-repo","title":"Setting up after cloning the repo","text":"<p>After cloning the repo, create a 'drivers' directory on the same level as 'src' and move the previously installed  MariaDB driver .jar file to this dir.</p> <p>When scanning through the constants.py file in src/api/, you'll see that some constants are derived from a yaml file.  Create a file called 'env.yml' directly in the 'src' directory and a 'test_env.yml' file in the 'src/tests/' directory.  The env.yml file will actually be used by the API. The test_env.yml file is used within the scope of code tests. For  simplicity's sake, it is advised to use rather simple user credentials for the testing scope e.g., admin:admin.  Both of these files should contain the following information: * DB_USER   * The MariaDB username of your python mariadb user.   * Should be a string. * DB_PW   * The MariaDB password of your python mariadb user. Its hash will be saved in the DB, not as a plain PW. This      password will simultaneously be used as the password for your personal API user.   * Should be a string. * DB_USER_NAME   * Username of your personal API user. This username is unique for all API users (wine/beer owners).   * Should be a string. * JWT_KEY   * Algorithm key for both decoding/encoding API access tokens.   * Should be a string. * JWT_ALGORITHM   * The preferred encoding/decoding algorithm.   * Should be a string. * ACCESS_TOKEN_EXPIRATION_MIN   * Duration in minutes of which debugging tokens are valid.   * Should be an integer.</p>"},{"location":"API/","title":"API","text":""},{"location":"API/#api-configuration","title":"API configuration","text":""},{"location":"API/#getting-started","title":"Getting Started","text":"<ol> <li> <p>Run the live server </p> <pre><code>uvicorn src.api.main:app --reload \n</code></pre> </li> <li> <p>Open the Swagger UI</p> <pre><code>http://127.0.0.01:8000/login\n</code></pre> </li> </ol>"},{"location":"API/#structure-api","title":"Structure API","text":"Folder Python file Contents src/api/ main An instance of the class FastAPI is created and routers are linked. constants Defining of constant values dependencies Dependency injection src/api/routers users_router A... cellar_router ... cellar_views_router ..."},{"location":"API/#users","title":"users","text":""},{"location":"API/#src.api.routers.users_router.add_user","title":"<code>add_user(user_db, owner_data)</code>  <code>async</code>","text":"<p>ADMIN ONLY ENDPOINT Add new wine/beer owner to the DB. Required scope(s): USERS:READ, USERS:WRITE</p> Source code in <code>src/api/routers/users_router.py</code> <pre><code>@router.post('/add', dependencies=[Security(get_current_active_user, scopes=['USERS:WRITE'])])\nasync def add_user(user_db: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                   owner_data: NewOwnerModel) -&gt; str:\n    \"\"\"\n    ADMIN ONLY ENDPOINT\n    Add new wine/beer owner to the DB.\n    Required scope(s): USERS:READ, USERS:WRITE\n    \"\"\"\n    # validate if user exists based on the unique username\n    user = user_db.execute_query_select(query=\"SELECT * FROM cellar.owners WHERE username = %(username)s\",\n                                        params={\"username\": owner_data.username})\n    if user:\n        raise HTTPException(status_code=400, detail=f\"A user with username {owner_data.username} already exists\")\n    user_db.execute_query(\"INSERT INTO cellar.owners (name, username, password, scopes, is_admin, enabled) \"\n                          \"VALUES (%(name)s, %(username)s, %(password)s, %(scopes)s, %(is_admin)s, \"\n                          \"        %(enabled)s)\",\n                          params={\"name\": owner_data.name, \"username\": owner_data.username,\n                                  \"password\": get_password_hash(password=owner_data.password),\n                                  \"scopes\": owner_data.scopes, \"is_admin\": owner_data.is_admin,\n                                  \"enabled\": owner_data.enabled})\n    return f\"User with username {owner_data.username} has successfully been added to the DB\"\n</code></pre>"},{"location":"API/#src.api.routers.users_router.delete_user","title":"<code>delete_user(user_db, delete_username)</code>  <code>async</code>","text":"<p>ADMIN ONLY ENDPOINT Delete existing wine/beer owner to the DB. Required scope(s): USERS:READ, USERS:WRITE</p> Source code in <code>src/api/routers/users_router.py</code> <pre><code>@router.delete('/delete', dependencies=[Security(get_current_active_user, scopes=['USERS:WRITE'])])\nasync def delete_user(user_db: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                      delete_username: str) -&gt; str:\n    \"\"\"\n    ADMIN ONLY ENDPOINT\n    Delete existing wine/beer owner to the DB.\n    Required scope(s): USERS:READ, USERS:WRITE\n    \"\"\"\n    # validate if user exists based on the unique username\n    user = user_db.execute_query_select(query=\"SELECT * FROM cellar.owners WHERE username = %(username)s\",\n                                        params={\"username\": delete_username})\n    if not user:\n        raise HTTPException(status_code=400, detail=f\"No users with username {delete_username} exist\")\n    user_db.execute_query(\"DELETE FROM cellar.owners WHERE username = %(username)s\",\n                          params={\"username\": delete_username})\n    return f\"User with username {delete_username} has successfully been removed from the DB\"\n</code></pre>"},{"location":"API/#src.api.routers.users_router.get_extended_access_token","title":"<code>get_extended_access_token(user_db, token_user, scopes, days_valid)</code>  <code>async</code>","text":"<p>ADMIN ONLY ENDPOINT Generate an access token with extended expiration date of up to a year. The token can be generated for any user in the database. Only scopes that the intended user is allowed to use can be added to this token. Required scope(s): USERS:READ, USERS:WRITE</p> Source code in <code>src/api/routers/users_router.py</code> <pre><code>@router.post(path='/extendedtoken', response_model=Token,\n             dependencies=[Security(get_current_active_user, scopes=['USERS:WRITE'])])\nasync def get_extended_access_token(user_db: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                                    token_user: Annotated[str, Form()],\n                                    scopes: Annotated[list[SCOPES_ENUM], Form()],\n                                    days_valid: Annotated[int, Form(..., ge=1, le=365)]):\n    \"\"\"\n    ADMIN ONLY ENDPOINT\n    Generate an access token with extended expiration date of up to a year. The token can be generated for any user in\n    the database. Only scopes that the intended user is allowed to use can be added to this token.\n    Required scope(s): USERS:READ, USERS:WRITE\n    \"\"\"\n    token_user_model = get_user(username=token_user, user_db=user_db)\n    if not token_user_model:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f'User {token_user} does not exist.')\n    access_token_expires = timedelta(days=days_valid)\n    access_token = create_access_token(data={'sub': token_user_model.username,\n                                             'scopes': verify_scopes(scopes=[str(s.value) for s in scopes],\n                                                                     user_scopes=token_user_model.scopes,\n                                                                     is_admin=token_user_model.is_admin)},\n                                       expires_delta=access_token_expires)\n\n    return {'access_token': access_token, 'token_type': 'bearer'}\n</code></pre>"},{"location":"API/#src.api.routers.users_router.get_users","title":"<code>get_users(user_db)</code>  <code>async</code>","text":"<p>Retrieve all registered wine/beer owners. Required scope(s): CELLAR:READ</p> Source code in <code>src/api/routers/users_router.py</code> <pre><code>@router.get('/get_users', response_model=list[OwnerModel], dependencies=[Security(get_current_active_user)])\nasync def get_users(user_db: Annotated[JdbcDbConn, Depends(DB_CONN)]) -&gt; list[OwnerModel]:\n    \"\"\"\n    Retrieve all registered wine/beer owners.\n    Required scope(s): CELLAR:READ\n    \"\"\"\n    return user_db.execute_query_select(query=\"SELECT id, name, username, scopes, is_admin, enabled \"\n                                              \"FROM cellar.owners\",\n                                        get_fields=True)\n</code></pre>"},{"location":"API/#src.api.routers.users_router.update_user","title":"<code>update_user(user_db, new_data, current_username)</code>  <code>async</code>","text":"<p>ADMIN ONLY ENDPOINT Updates existing wine/beer owner in the DB. Required scope(s): USERS:READ, USERS:WRITE</p> Source code in <code>src/api/routers/users_router.py</code> <pre><code>@router.patch('/update', dependencies=[Security(get_current_active_user, scopes=['USERS:WRITE'])])\nasync def update_user(user_db: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                      new_data: UpdateOwnerModel,\n                      current_username: str) -&gt; str:\n    \"\"\"\n    ADMIN ONLY ENDPOINT\n    Updates existing wine/beer owner in the DB.\n    Required scope(s): USERS:READ, USERS:WRITE\n    \"\"\"\n\n    # Validate whether the new username exists and if so, if it exists in the DB\n    new_user = user_db.execute_query_select(query=\"SELECT * FROM cellar.owners WHERE username = %(username)s\",\n                                            params={\"username\": new_data.username},\n                                            get_fields=True)\n    if len(new_user) and new_user[0]['username'] != current_username:\n        raise HTTPException(status_code=400, detail=f\"Users with username {new_user[0]['username']} exist. Please \"\n                                                    f\"provide a unique new username.\")\n\n    # Find updated values and construct query string\n    update_fields = {}\n    for k, v in new_data.dict(exclude_unset=True).items():\n        if k == \"password\":\n            # Hash the new password\n            update_fields[k] = get_password_hash(v)\n        else:\n            update_fields[k] = v\n\n    updated_fields = \", \".join(f\"{field} = %({field})s\" for field in update_fields)\n    user_db.execute_query(f\"UPDATE cellar.owners SET {updated_fields} WHERE username = %(current_username)s\",\n                          params={\"current_username\": current_username, **update_fields})\n\n    return \"User information updated successfully.\"\n</code></pre>"},{"location":"API/#cellar","title":"cellar","text":""},{"location":"API/#src.api.routers.cellar_router.add_a_rating","title":"<code>add_a_rating(db_conn, current_user, wine_id, rating)</code>  <code>async</code>","text":"<p>Adds a rating to your DB. Note that if you've drunk a bottle, you can make use of the '/wine_in_cellar/consumed' endpoint to both add a rating and update your storage.</p> <p>Required scope(s): CELLAR:READ, CELLAR:WRITE</p> Source code in <code>src/api/routers/cellar_router.py</code> <pre><code>@router.post(\"/wine_in_cellar/add_rating\", dependencies=[Security(get_current_active_user)])\nasync def add_a_rating(db_conn: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                       current_user: Annotated[OwnerModel, Depends(get_current_active_user)],\n                       wine_id: int,\n                       rating: RatingModel) -&gt; str:\n    \"\"\"\n    Adds a rating to your DB. Note that if you've drunk a bottle, you can make use of the '/wine_in_cellar/consumed'\n    endpoint to both add a rating and update your storage.\n\n    Required scope(s): CELLAR:READ, CELLAR:WRITE\n    \"\"\"\n    # Verify the wine exists in the DB\n    if not await wine_in_db(db_conn=db_conn, wine_id=wine_id):\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,\n                            detail=f\"Wine with wine_id: {wine_id} is not found in the DB. Make sure to use an \"\n                                   f\"existing wine ID in order to rate the correct wine\")\n    await add_rating_to_db(db_conn=db_conn, user_id=current_user.id, wine_id=wine_id, rating=rating)\n    return \"Rating has successfully been added to the DB\"\n</code></pre>"},{"location":"API/#src.api.routers.cellar_router.add_wine_to_cellar","title":"<code>add_wine_to_cellar(db_conn, current_user, wine_data)</code>  <code>async</code>","text":"<p>Adds bottles to your cellar. Make sure to provide the correct storage unit ID. You can check what storages you can add wines to from the '/storages/get' endpoint.</p> <p>Required scope(s): CELLAR:READ, CELLAR:WRITE</p> Source code in <code>src/api/routers/cellar_router.py</code> <pre><code>@router.post(\"/wine_in_cellar/add\", dependencies=[Security(get_current_active_user)])\nasync def add_wine_to_cellar(db_conn: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                             current_user: Annotated[OwnerModel, Depends(get_current_active_user)],\n                             wine_data: CellarInModel) -&gt; str:\n    \"\"\"\n    Adds bottles to your cellar. Make sure to provide the correct storage unit ID. You can check what storages you can\n    add wines to from the '/storages/get' endpoint.\n\n    Required scope(s): CELLAR:READ, CELLAR:WRITE\n    \"\"\"\n    # Check if storage unit is valid\n    if not await verify_storage_exists_for_user(db_conn=db_conn, storage_id=wine_data.storage_unit,\n                                                user_id=current_user.id):\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,\n                            detail=\"Storage unit is not found for your particular user.\")\n\n    # Inspect if the wine is already in the wines table\n    if not await verify_wine_in_db(db_conn=db_conn, name=wine_data.wine_info.name, vintage=wine_data.wine_info.vintage):\n        # If not, add data to the wines table\n        await add_wine_to_db(db_conn=db_conn, wine_info=wine_data.wine_info)\n\n    # Retrieve wine ID from the wines table\n    wine_id = await get_bottle_id(db_conn=db_conn, name=wine_data.wine_info.name, vintage=wine_data.wine_info.vintage)\n\n    # Insert all info into the cellar table\n    await add_bottle_to_cellar(db_conn=db_conn, wine_id=wine_id, owner_id=current_user.id, wine_data=wine_data)\n\n    return \"Bottle has successfully been added to the DB\"\n</code></pre>"},{"location":"API/#src.api.routers.cellar_router.delete_storage_unit","title":"<code>delete_storage_unit(db_conn, current_user, location, description)</code>  <code>async</code>","text":"<p>Delete a storage unit to the DB. Provide the location and description of the storage unit to select which unit should be deleted. Make sure that the storage unit is empty whenever you want to remove it.</p> <p>Required scope(s): CELLAR:READ, CELLAR:WRITE</p> Source code in <code>src/api/routers/cellar_router.py</code> <pre><code>@router.delete(\"/storages/delete\", dependencies=[Security(get_current_active_user)])\nasync def delete_storage_unit(db_conn: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                              current_user: Annotated[OwnerModel, Depends(get_current_active_user)],\n                              location: Annotated[str, Query(max_length=200)],\n                              description: Annotated[str, Query(max_length=200)]) -&gt; str:\n    \"\"\"\n    Delete a storage unit to the DB. Provide the location and description of the storage unit to select which unit\n    should be deleted. Make sure that the storage unit is empty whenever you want to remove it.\n\n    Required scope(s): CELLAR:READ, CELLAR:WRITE\n    \"\"\"\n    # Verify empty storage unit\n    storage_id = await get_storage_id(db_conn=db_conn, current_user_id=current_user.id,\n                                      location=location, description=description)\n\n    # Remove the storage unit from DB if it is empty.\n    # Note that `verify_empty_storage_unit` raises and error if the storage unit is not empty\n    if await verify_empty_storage_unit(db_conn=db_conn, storage_id=storage_id[0]):\n        db_conn.execute_query((\"DELETE FROM cellar.storages \"\n                               \"WHERE location = %(location)s \"\n                               \"  AND description = %(description)s \"\n                               \"  AND owner_id = %(owner_id)s\"),\n                              params={\"location\": location, \"description\": description, \"owner_id\": current_user.id})\n\n    return \"Storage unit has successfully been removed from the DB\"\n</code></pre>"},{"location":"API/#src.api.routers.cellar_router.move_bottle_to_other_storage","title":"<code>move_bottle_to_other_storage(db_conn, current_user, cellar_id, new_storage_unit)</code>  <code>async</code>","text":"<p>Move a bottle from one storage unit to another.</p> <p>Required scope(s): CELLAR:READ, CELLAR:WRITE</p> Source code in <code>src/api/routers/cellar_router.py</code> <pre><code>@router.patch(\"/wine_in_cellar/move\", dependencies=[Security(get_current_active_user)])\nasync def move_bottle_to_other_storage(db_conn: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                                       current_user: Annotated[OwnerModel, Depends(get_current_active_user)],\n                                       cellar_id: int,\n                                       new_storage_unit: int) -&gt; str:\n    \"\"\"\n    Move a bottle from one storage unit to another.\n\n    Required scope(s): CELLAR:READ, CELLAR:WRITE\n    \"\"\"\n    if await verify_storage_exists_for_user(db_conn=db_conn, storage_id=new_storage_unit, user_id=current_user.id):\n        db_conn.execute_query(\"UPDATE cellar.cellar SET storage_unit = %(storage_unit)s WHERE id = %(cellar_id)s\",\n                              params={\"storage_unit\": new_storage_unit, \"cellar_id\": cellar_id})\n        return f\"Bottle has successfully been transferred to storage unit {new_storage_unit}\"\n    else:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,\n                            detail=\"Storage unit is not found for your particular user.\")\n</code></pre>"},{"location":"API/#src.api.routers.cellar_router.post_storage_unit","title":"<code>post_storage_unit(db_conn, current_user, storage_data)</code>  <code>async</code>","text":"<p>Add a storage unit to the DB.</p> <p>Required scope(s): CELLAR:READ, CELLAR:WRITE</p> Source code in <code>src/api/routers/cellar_router.py</code> <pre><code>@router.post(\"/storages/add\", dependencies=[Security(get_current_active_user)])\nasync def post_storage_unit(db_conn: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                            current_user: Annotated[OwnerModel, Depends(get_current_active_user)],\n                            storage_data: StorageInModel) -&gt; str:\n    \"\"\"\n    Add a storage unit to the DB.\n\n    Required scope(s): CELLAR:READ, CELLAR:WRITE\n    \"\"\"\n    db_conn.execute_query((\"INSERT INTO cellar.storages (owner_id, location, description) \"\n                           \"VALUES (%(owner_id)s, %(location)s, %(description)s)\"),\n                          params={\"owner_id\": current_user.id, \"location\": storage_data.location,\n                                  \"description\": storage_data.description})\n\n    return \"Storage unit has successfully been added to the DB\"\n</code></pre>"},{"location":"API/#src.api.routers.cellar_router.remove_consumed_from_stock","title":"<code>remove_consumed_from_stock(db_conn, current_user, bottle_data, rate_bottle=True, rating=None)</code>  <code>async</code>","text":"<p>Removes a bottle from your cellar, if the 'rate_bottle' flag is set to True, the rating argument is required, else it will be ignored and can be left in the default state.</p> <p>Required scope(s): CELLAR:READ, CELLAR:WRITE</p> Source code in <code>src/api/routers/cellar_router.py</code> <pre><code>@router.patch(\"/wine_in_cellar/consumed\", dependencies=[Security(get_current_active_user)])\nasync def remove_consumed_from_stock(db_conn: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                                     current_user: Annotated[OwnerModel, Depends(get_current_active_user)],\n                                     bottle_data: ConsumedBottleModel,\n                                     rate_bottle: bool = True,\n                                     rating: RatingModel | None = None) -&gt; str:\n    \"\"\"\n    Removes a bottle from your cellar, if the 'rate_bottle' flag is set to True, the rating argument is required, else\n    it will be ignored and can be left in the default state.\n\n    Required scope(s): CELLAR:READ, CELLAR:WRITE\n    \"\"\"\n    # Verify the wine exists in the DB\n    if not await wine_in_db(db_conn=db_conn, wine_id=bottle_data.wine_id):\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,\n                            detail=f\"Wine with wine_id: {bottle_data.wine_id} is not found in the DB. Make sure to use \"\n                                   f\"an existing wine ID in order to mark the correct wine as consumed\")\n    # Add a rating to the DB if the data is provided\n    if rate_bottle:\n        await add_rating_to_db(db_conn=db_conn, user_id=current_user.id, wine_id=bottle_data.wine_id, rating=rating)\n\n    await update_quantity_in_cellar(db_conn=db_conn, wine_id=bottle_data.wine_id, bottle_data=bottle_data, add=False)\n    return \"Consumed bottle is updated in the DB\"\n</code></pre>"},{"location":"API/#cellar_views","title":"cellar_views","text":""},{"location":"API/#src.api.routers.cellar_views_router.get_bottle_open_window","title":"<code>get_bottle_open_window(db_conn, current_user, drink_year=None, beverage_type=None)</code>  <code>async</code>","text":"<p>Retrieve all bottles that are drinkable now or within a specified year. The returned list of drink-ready bottles can be trimmed by specifying a certain beverage_type.</p> <p>Required scope(s): CELLAR:READ</p> Source code in <code>src/api/routers/cellar_views_router.py</code> <pre><code>@router.get(\"/wine_in_cellar/drink_in_window\", response_model=list[CellarOutModel],\n            dependencies=[Security(get_current_active_user)])\nasync def get_bottle_open_window(db_conn: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                                 current_user: Annotated[OwnerModel, Depends(get_current_active_user)],\n                                 drink_year: int | None = None,\n                                 beverage_type: str | None = None) -&gt; list[CellarOutModel]:\n    \"\"\"\n    Retrieve all bottles that are drinkable now or within a specified year. The returned list of drink-ready bottles\n    can be trimmed by specifying a certain beverage_type.\n\n    Required scope(s): CELLAR:READ\n    \"\"\"\n    drink_when_cond = 'c.drink_from &lt;= %(drink_year)s AND c.drink_before &gt;= %(drink_year)s'\n    owner_cond = 'c.owner_id = %(user_id)s'\n    drink_year = datetime.now().year if drink_year is None else drink_year\n\n    params = {\"drink_year\": datetime(year=drink_year, month=1, day=1), \"user_id\": current_user.id}\n    where = f'WHERE {drink_when_cond} AND {owner_cond} '\n    if beverage_type is not None:\n        params[\"bev_type\"] = beverage_type\n        where += f'AND w.type = %(bev_type)s'\n    return get_cellar_out_data(db_conn=db_conn, params=params, where=where)\n</code></pre>"},{"location":"API/#src.api.routers.cellar_views_router.get_owners","title":"<code>get_owners(current_user)</code>  <code>async</code>","text":"<p>Retrieve your ID.</p> <p>Required scope(s): CELLAR:READ</p> Source code in <code>src/api/routers/cellar_views_router.py</code> <pre><code>@router.get(\"/owners/get_your_id\", dependencies=[Security(get_current_active_user)])\nasync def get_owners(current_user: Annotated[OwnerModel, Depends(get_current_active_user)]) -&gt; int:\n    \"\"\"\n    Retrieve your ID.\n\n    Required scope(s): CELLAR:READ\n    \"\"\"\n    return current_user.id\n</code></pre>"},{"location":"API/#src.api.routers.cellar_views_router.get_stock_on_bottle","title":"<code>get_stock_on_bottle(db_conn, current_user, wine_id)</code>  <code>async</code>","text":"<p>Get an overview of all your bottles of a specific wine stored in your cellar.</p> <p>Required scope(s): CELLAR:READ</p> Source code in <code>src/api/routers/cellar_views_router.py</code> <pre><code>@router.get(\"/wine_in_cellar/get_stock_on_bottle\",  response_model=list[CellarOutModel],\n            dependencies=[Security(get_current_active_user)])\nasync def get_stock_on_bottle(db_conn: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                              current_user: Annotated[OwnerModel, Depends(get_current_active_user)],\n                              wine_id: int) -&gt; list[CellarOutModel]:\n    \"\"\"\n    Get an overview of all your bottles of a specific wine stored in your cellar.\n\n    Required scope(s): CELLAR:READ\n    \"\"\"\n    return get_cellar_out_data(db_conn=db_conn, params={\"user_id\": current_user.id, \"wine_id\": wine_id},\n                               where=\"WHERE c.owner_id = %(user_id)s AND wine_id = %(wine_id)s\")\n</code></pre>"},{"location":"API/#src.api.routers.cellar_views_router.get_storage_units","title":"<code>get_storage_units(db_conn, current_user)</code>  <code>async</code>","text":"<p>Retrieve all your storage units registered within the DB.</p> <p>Required scope(s): CELLAR:READ</p> Source code in <code>src/api/routers/cellar_views_router.py</code> <pre><code>@router.get(\"/storages/get\", response_model=list[StorageOutModel], dependencies=[Security(get_current_active_user)])\nasync def get_storage_units(db_conn: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                            current_user: Annotated[OwnerModel, Depends(get_current_active_user)]\n                            ) -&gt; list[StorageOutModel]:\n    \"\"\"\n    Retrieve all your storage units registered within the DB.\n\n    Required scope(s): CELLAR:READ\n    \"\"\"\n    return db_conn.execute_query_select(query=\"SELECT * FROM cellar.storages WHERE owner_id = %(owner_id)s\",\n                                        params={\"owner_id\": current_user.id},\n                                        get_fields=True)\n</code></pre>"},{"location":"API/#src.api.routers.cellar_views_router.get_wine_rating","title":"<code>get_wine_rating(db_conn, current_user, wine_id, only_your_ratings=True)</code>  <code>async</code>","text":"<p>Retrieves ratings for a specific wine/bottle. Make sure to set the 'only_your_ratings' to True if you only want to see your ratings on the wine. If set to False, all ratings will be given.</p> <p>Required scope(s): CELLAR:READ</p> Source code in <code>src/api/routers/cellar_views_router.py</code> <pre><code>@router.get(\"/wine_in_cellar/get_wine_ratings\", response_model=list[RatingInDbModel],\n            dependencies=[Security(get_current_active_user)])\nasync def get_wine_rating(db_conn: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                          current_user: Annotated[OwnerModel, Depends(get_current_active_user)],\n                          wine_id: int,\n                          only_your_ratings: bool = True) -&gt; list[RatingInDbModel]:\n    \"\"\"\n    Retrieves ratings for a specific wine/bottle. Make sure to set the 'only_your_ratings' to True if you only want\n    to see your ratings on the wine. If set to False, all ratings will be given.\n\n    Required scope(s): CELLAR:READ\n    \"\"\"\n    # Verify the wine exists in the DB\n    if not await wine_in_db(db_conn=db_conn, wine_id=wine_id):\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,\n                            detail=f\"Wine with wine_id: {wine_id} is not found in the DB. Make sure to use an \"\n                                   f\"existing wine ID in order to rate the correct wine\")\n    # Retrieve the ratings from the DB\n    query = \"SELECT * FROM cellar.ratings WHERE wine_id = %(wine_id)s\"\n    if only_your_ratings:\n        # Note that an f-string is used for the rater_id since sql-injection risks are mitigated due to the user id\n        # originating from the OwnerModel and thus enforcing the value to be an integer\n        query = f\"{query} AND rater_id = '{current_user.id}'\"\n    return db_conn.execute_query_select(query=query, params={\"wine_id\": wine_id}, get_fields=True)\n</code></pre>"},{"location":"API/#src.api.routers.cellar_views_router.get_your_bottles","title":"<code>get_your_bottles(db_conn, current_user, storage_unit=None)</code>  <code>async</code>","text":"<p>Get an overview of all your bottles stored in your cellar. If the 'storage_unit' id is specified, only the bottles in that specific storage unit are shown.</p> <p>Required scope(s): CELLAR:READ</p> Source code in <code>src/api/routers/cellar_views_router.py</code> <pre><code>@router.get(\"/wine_in_cellar/get_your_bottles\", response_model=list[CellarOutModel],\n            dependencies=[Security(get_current_active_user)])\nasync def get_your_bottles(db_conn: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                           current_user: Annotated[OwnerModel, Depends(get_current_active_user)],\n                           storage_unit: int | None = None) -&gt; list[CellarOutModel]:\n    \"\"\"\n    Get an overview of all your bottles stored in your cellar. If the 'storage_unit' id is specified, only the bottles\n    in that specific storage unit are shown.\n\n    Required scope(s): CELLAR:READ\n    \"\"\"\n    if storage_unit is None:\n        return get_cellar_out_data(db_conn=db_conn, params={\"user_id\": current_user.id},\n                                   where=\"WHERE c.owner_id = %(user_id)s\")\n    else:\n        return get_cellar_out_data(db_conn=db_conn, params={\"user_id\": current_user.id, \"storage_unit\": storage_unit},\n                                   where=\"WHERE c.owner_id = %(user_id)s AND storage_unit = %(storage_unit)s\")\n</code></pre>"},{"location":"API/#src.api.routers.cellar_views_router.get_your_ratings","title":"<code>get_your_ratings(db_conn, current_user)</code>  <code>async</code>","text":"<p>Retrieves all your ratings for all wines/bottles.</p> <p>Required scope(s): CELLAR:READ</p> Source code in <code>src/api/routers/cellar_views_router.py</code> <pre><code>@router.get(\"/wine_in_cellar/get_your_ratings\", response_model=list[RatingInDbModel],\n            dependencies=[Security(get_current_active_user)])\nasync def get_your_ratings(db_conn: Annotated[JdbcDbConn, Depends(DB_CONN)],\n                           current_user: Annotated[OwnerModel, Depends(get_current_active_user)]\n                           ) -&gt; list[RatingInDbModel]:\n    \"\"\"\n    Retrieves all your ratings for all wines/bottles.\n\n    Required scope(s): CELLAR:READ\n    \"\"\"\n    # Retrieve the ratings from the DB\n    return db_conn.execute_query_select(query=\"SELECT * FROM cellar.ratings WHERE rater_id = %(rater_id)s\",\n                                        params={\"rater_id\": current_user.id}, get_fields=True)\n</code></pre>"},{"location":"API/#api-choices","title":"API choices","text":""},{"location":"API/#fastapi","title":"FastAPI","text":"<p>...</p>"},{"location":"API/#partition-key-and-id-in-the-cosmos-db","title":"Partition Key and ID in the cosmos DB","text":""},{"location":"API/#authentication","title":"Authentication","text":"<p>oath2</p>"},{"location":"database/","title":"Database","text":""},{"location":"database/#database-configuration","title":"Database configuration","text":"<p>Describe the configuration we used to create the database. Could also show the ARM template here. </p>"},{"location":"database/#database-choices","title":"Database choices","text":"<p>Describe why we have chosen the database that we use. Adress pros and cons of the choices.</p>"},{"location":"database/#database-cost","title":"Database cost","text":"<p>Describe what costs can be expected by using this configuration of the database. </p>"},{"location":"projectoverview/","title":"Project Overview","text":"<p>What is the overal structure of our project?</p>"},{"location":"swagger_ui/","title":"SWAGGER UI","text":""}]}